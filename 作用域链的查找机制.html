<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
        /* 作用域查找机制关键点在于如何查找上级作用域
        1.从函数创建开始，作用域链就已经指定好了
        2.当前函数是在哪个作用域(N)创建的，那么函数执行形成的作用域(M)的上级作用域就是(N)，和函数在哪执行没有关系，和在哪创建有关系
        */
        var n = 1
        function fn() {
            var n = 2
            function f() {
                n--
                console.log(n)
            }
            f()
            return f
        }
        var x = fn()
        x()
        console.log(n)



        var i = 0
        function A() {
            var i = 10
            // x是在函数A执行的时候创建的
            function x() {
                console.log(i)
            }
            return x
        }
        var y = A() // y=x
        y() // 输出10
        function B() {
            var i = 20
            y()
        }
        B() // 输出10




        /* 闭包作用域
        1.创建函数
            开辟一个堆内存
            把函数体中的代码当做字符串存储进去
            把堆内存的地址赋值给函数名/变量名
            重点！！！！函数在哪创建的，那么它执行时所需要查找的上级作用域是谁
        2.函数执行
            形成一个全新的私有作用域/执行上下文/私有栈内存（执行一次形成一个，多次执行也不会相互影响）
            形参赋值&变量提升
            代码执行（把所属对内存中的代码字符串拿出来一行一行的执行）
            重点！！！！遇到一个变量，首先看它是否为私有变量（形参和在私有作用域中声明的变量是私有变量），是私有变量的话就操作私有变量，不是私有的，就向上级作用域查找，一直找到全局作用域为止 => 作用域链查找机制
            私有变量和外界变量没有必然联系，可以理解为被私有栈内存保护起来了，这种机制其实就是（闭包的保护机制）
        3.关于堆栈内存释放问题
            函数执行就会形成栈内存（从内存中分配一块空间），如果内存都不销毁释放，很容易就会导致栈溢出（内存爆满，电脑卡死）。堆栈内存的释放问题是学习JS的核心知识之一
            堆内存释放问题：
                创建一个引用类型值，就会产生一个堆内存
                如果当前创建的堆内存不被其它东西所占用了（浏览器会在空闲的时候，查找每一个内存的饮用情况，不被占用的都会给回收掉）则会释放
                let obj = { name: 'aa' }
                let oop = obj
                此时obj和oop都占用着对象的堆内存，想要释放内存，需要手动解除变量和值的关联
                obj = bull
                oop = null
            栈内存释放问题
                打开浏览器形成的全局作用域是栈内存
                手动执行函数形成的私有作用域是栈内存
                基于ES6中的let/const形成的块级作用域是栈内存

                全局栈内存：关掉网页的时候才会销毁
                私有栈内存：
                    1.一般情况下，函数只要执行完成，形成的私有栈内存就会被销毁掉
                        function fn() {}
                        fn() 函数执行形成栈内存，执行完成栈内存销毁（排除出现无限极递归、出现死循环的模式）
                    2.但是一旦栈内存中的某个东西（一般都是堆地址）被私有作用域以外的事物给占用了，则当前栈内存不能立即被释放销毁（特点：私有作用域中的私有变量等信息也被保留下来了）
                    =>市面上认为的闭包：函数执行形成不能被释放的私有栈内存，这样的才是闭包
                        function X() {
                            return function() {}
                        }
                        let f = x() f占用了X执行形成栈内存中的一个东西（返回小函数对应的堆），则X执行形成的栈内存
        */

        var i = 5
        function fn(i) {
            return function (n) {
                console.log(n + (++i))
            }
        }
        var f = fn(1)
        f(2) // 4
        fn(3)(4) // 8
        fn(5)(6) // 12
        f(7) // 10
        console.log(i) // 5


        /* 闭包的两大作用
        1.保护（私有变量和外界没有必然联系）
        2.保存（形成不销毁的栈内存，里面的私有变量等信息保存下来）
         */
    </script>
</body>
</html>