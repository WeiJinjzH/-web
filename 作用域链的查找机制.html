<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
        /* 作用域查找机制关键点在于如何查找上级作用域
        1.从函数创建开始，作用域链就已经指定好了
        2.当前函数是在哪个作用域(N)创建的，那么函数执行形成的作用域(M)的上级作用域就是(N)，和函数在哪执行没有关系，和在哪创建有关系
        */
        var n = 1
        function fn() {
            var n = 2
            function f() {
                n--
                console.log(n)
            }
            f()
            return f
        }
        var x = fn()
        x()
        console.log(n)



        var i = 0
        function A() {
            var i = 10
            // x是在函数A执行的时候创建的
            function x() {
                console.log(i)
            }
            return x
        }
        var y = A() // y=x
        y() // 输出10
        function B() {
            var i = 20
            y()
        }
        B() // 输出10




        /* 闭包作用域
        1.创建函数
            开辟一个堆内存
            把函数体中的代码当做字符串存储进去
            把堆内存的地址赋值给函数名/变量名
            重点！！！！函数在哪创建的，那么它执行时所需要查找的上级作用域是谁
        2.函数执行
            形成一个全新的私有作用域/执行上下文/私有栈内存（执行一次形成一个，多次执行也不会相互影响）
            形参赋值&变量提升
            代码执行（把所属对内存中的代码字符串拿出来一行一行的执行）
            重点！！！！遇到一个变量，首先看它是否为私有变量（形参和在私有作用域中声明的变量是私有变量），是私有变量的话就操作私有变量，不是私有的，就向上级作用域查找，一直找到全局作用域为止 => 作用域链查找机制
            私有变量和外界变量没有必然联系，可以理解为被私有栈内存保护起来了，这种机制其实就是（闭包的保护机制）
        */
    </script>
</body>
</html>